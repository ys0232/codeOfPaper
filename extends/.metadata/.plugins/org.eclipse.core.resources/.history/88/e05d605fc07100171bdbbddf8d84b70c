package taskscheduling;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import taskscheduling.Processor;
import taskscheduling.Task;
import taskscheduling.util.*;

public class newtestUpdate {
    public static String newtestUpdate(ArrayList<Task> taskList, Processor[] processorsArray, int k, HashMap<Integer, String> bestList,
                                     HashMap<String, Double> taskEdgeHashMap, double beta) {

        String[] str ;
        int taskid = k;
        str =bestList.get(k).split("_");
        Task task = taskList.get(taskid);

        //重置处理器的可用时间信息
        for (Processor processor : processorsArray) {
            processor.availableTime = Double.MIN_VALUE;
        }
        //跳过要调换的任务之前的任务
        int updateIndex = 0;
        for (; updateIndex < taskList.size(); ++updateIndex) {
            if (updateIndex == taskid) {
                break;
            }
            Task tempTask = taskList.get(updateIndex);
            int processorId = tempTask.selectedProcessorId;
            double tempAvailableTime = tempTask.timeGap.endTime;
            processorsArray[processorId].availableTime = Math.max(tempAvailableTime, processorsArray[processorId].availableTime);
        }
        //寻找父节点任务的最晚结束时间
        ArrayList<Integer> predTaskArrayList = taskList.get(taskid).predecessorTaskList;
        //父节点的最晚结束时间
        double timeThreshold = -1;
        for (Integer predTaskId : predTaskArrayList) {
            double temp = 0;
            Task predTask = taskList.get(predTaskId );
            if (predTask.selectedProcessorId == Integer.valueOf(str[0])){
                temp = predTask.timeGap.endTime;
            } else {
                // System.out.println(predTaskId + "_" + taskid);
                temp = predTask.timeGap.endTime + taskEdgeHashMap.get(predTaskId + "_" + (taskid));
            }
            if (timeThreshold < temp) {
                timeThreshold = temp;
            }
        }

        task.selectedProcessorId = Integer.valueOf(str[0]);
        task.selectedFre = Integer.valueOf(str[1]);
        task.timeGap.startTime = Math.max(timeThreshold, processorsArray[Integer.valueOf(str[0])].availableTime);
        double excuTime = CalcRunTime.calcRunTime(beta, task.selectedFre,
                processorsArray[task.selectedProcessorId], task.computationCost.get(task.selectedProcessorId));
        task.timeGap.endTime = task.timeGap.startTime + excuTime;
        task.timeGap.gap = excuTime;
        processorsArray[task.selectedProcessorId].availableTime = task.timeGap.endTime;

        ++updateIndex;
        //保持任务的处理器不变，更新时间
        for (; updateIndex < taskList.size(); ++updateIndex) {
            UpdateTaskInforAfterChangeScheduling.updateTaskInforNew(updateIndex, taskList,beta, taskEdgeHashMap, processorsArray);

        }
        double makespan = CalcMakeSpan.calcMakeSpan(taskList);
        double sumCost = CalaCostofAll.calcCostofAll(taskList, processorsArray, beta);
        return makespan+" _"+sumCost;


    }
}
